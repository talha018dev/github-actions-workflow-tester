name: Cursor AI PR Review

on:
  pull_request:
    types: [opened, synchronize, reopened, ready_for_review]
  workflow_dispatch:

env:
  NODE_VERSION: '20'

jobs:
  cursor-ai-review:
    name: Cursor AI-Powered PR Review
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write
      issues: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Get PR changes
        id: pr-changes
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number,
            });
            
            const { data: files } = await github.rest.pulls.listFiles({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number,
            });
            
            const codeFiles = files
              .filter(f => f.status !== 'removed' && 
                      (f.filename.endsWith('.ts') || f.filename.endsWith('.tsx') || 
                       f.filename.endsWith('.js') || f.filename.endsWith('.jsx') ||
                       f.filename.endsWith('.css')))
              .map(f => ({
                filename: f.filename,
                status: f.status,
                additions: f.additions,
                deletions: f.deletions,
                patch: f.patch ? f.patch.substring(0, 5000) : ''
              }));
            
            core.setOutput('pr-data', JSON.stringify({
              title: pr.title,
              body: pr.body || '',
              files: codeFiles
            }));

      - name: Run AI Review
        id: ai-review
        uses: actions/github-script@v7
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          CURSOR_API_KEY: ${{ secrets.CURSOR_API_KEY }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const https = require('https');
            const prDataStr = '${{ steps.pr-changes.outputs.pr-data }}';
            
            if (!prDataStr) {
              core.setOutput('review', 'âš ï¸ Failed to get PR data.');
              return;
            }
            
            let prData;
            try {
              prData = JSON.parse(prDataStr);
            } catch (e) {
              core.setOutput('review', `âš ï¸ Failed to parse PR data: ${e.message}`);
              return;
            }
            
            const apiKey = process.env.CURSOR_API_KEY || process.env.OPENAI_API_KEY;
            
            if (!apiKey) {
              core.setOutput('review', 'âš ï¸ Neither CURSOR_API_KEY nor OPENAI_API_KEY is configured. Please add one in repository secrets.');
              return;
            }
            
            if (!prData.files || prData.files.length === 0) {
              core.setOutput('review', 'âœ… No code files changed in this PR.');
              return;
            }
            
            const systemPrompt = 'You are an expert code reviewer specializing in Next.js, React, TypeScript, and modern web development. Provide a concise, actionable code review focusing on: 1. Critical Issues: Security vulnerabilities, bugs, or breaking changes 2. Code Quality: Best practices, patterns, and maintainability 3. Suggestions: Specific improvements with code examples when helpful 4. Positive Feedback: Acknowledge good practices and clean code. Format your response in markdown with clear sections. Be constructive and specific.';
            
            const fileSummaries = prData.files.map(f => {
              const patch = f.patch || 'No diff available';
              const truncated = patch.length > 3000 ? patch.substring(0, 3000) + '...' : patch;
              return '### ' + f.filename + ' (' + f.status + ')\n- Additions: +' + f.additions + ', Deletions: -' + f.deletions + '\n```diff\n' + truncated + '\n```';
            }).join('\n\n');
            
            const userPrompt = 'Review this pull request:\n\n**PR Title**: ' + (prData.title || 'N/A') + '\n**PR Description**: ' + (prData.body || 'No description provided') + '\n\n**Changed Files**:\n' + fileSummaries + '\n\nPlease provide a comprehensive code review.';
            
            const data = JSON.stringify({
              model: 'gpt-4-turbo-preview',
              messages: [
                { role: 'system', content: systemPrompt },
                { role: 'user', content: userPrompt }
              ],
              temperature: 0.3,
              max_tokens: 2000,
            });
            
            return new Promise((resolve) => {
              const options = {
                hostname: 'api.openai.com',
                port: 443,
                path: '/v1/chat/completions',
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  'Authorization': 'Bearer ' + apiKey,
                  'Content-Length': data.length,
                },
              };
              
              const req = https.request(options, (res) => {
                let responseData = '';
                res.on('data', (chunk) => { responseData += chunk; });
                res.on('end', () => {
                  try {
                    if (res.statusCode === 200) {
                      const response = JSON.parse(responseData);
                      const review = response.choices[0].message.content;
                      core.setOutput('review', review);
                    } else {
                      const errorMsg = responseData.length > 500 ? responseData.substring(0, 500) : responseData;
                      core.setOutput('review', 'âš ï¸ Error generating AI review (' + res.statusCode + '): ' + errorMsg);
                    }
                  } catch (e) {
                    core.setOutput('review', 'âš ï¸ Error parsing response: ' + e.message);
                  }
                  resolve();
                });
              });
              
              req.on('error', (error) => {
                core.setOutput('review', 'âš ï¸ Error calling API: ' + error.message);
                resolve();
              });
              
              req.setTimeout(30000, () => {
                req.destroy();
                core.setOutput('review', 'âš ï¸ Request timeout after 30 seconds');
                resolve();
              });
              
              req.write(data);
              req.end();
            });

      - name: Post Review Comment
        uses: actions/github-script@v7
        if: steps.ai-review.outputs.review
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const review = '${{ steps.ai-review.outputs.review }}';
            
            if (!review || review.includes('âš ï¸')) {
              console.log('Skipping comment due to review error or warning');
              return;
            }
            
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });
            
            const existingComment = comments.find(c => 
              c.user.type === 'Bot' && 
              c.body.includes('ðŸ¤– Cursor AI Code Review')
            );
            
            const commentBody = '## ðŸ¤– Cursor AI Code Review\n\n' + review + '\n\n---\n*This review was automatically generated using Cursor AI via GitHub Actions.*';
            
            if (existingComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: existingComment.id,
                body: commentBody
              });
            } else {
              await github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: commentBody
              });
            }

