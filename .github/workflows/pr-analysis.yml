name: PR Analysis & Review (with Cursor)

on:
  pull_request:
    types: [opened, synchronize, reopened, ready_for_review]
  workflow_dispatch:

env:
  NODE_VERSION: '20'
  # SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
  # SONAR_ORGANIZATION: ${{ secrets.SONAR_ORGANIZATION }}
  CURSOR_API_KEY: ${{ secrets.CURSOR_API_KEY }}
  OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}

jobs:
  # codeql-analysis:
  #   name: CodeQL Security Analysis
  #   runs-on: ubuntu-latest
  #   permissions:
  #     actions: read
  #     contents: read
  #     security-events: write
  #
  #   strategy:
  #     fail-fast: false
  #     matrix:
  #       language: ['javascript', 'typescript']
  #
  #   steps:
  #     - name: Checkout repository
  #       uses: actions/checkout@v4
  #
  #     - name: Initialize CodeQL
  #       uses: github/codeql-action/init@v3
  #       with:
  #         languages: ${{ matrix.language }}
  #         queries: security-extended,security-and-quality
  #
  #     - name: Setup Node.js
  #       uses: actions/setup-node@v4
  #       with:
  #         node-version: ${{ env.NODE_VERSION }}
  #         cache: 'npm'
  #
  #     - name: Install dependencies
  #       run: npm ci
  #
  #     - name: Perform CodeQL Analysis
  #       uses: github/codeql-action/analyze@v3
  #       with:
  #         category: "/language:${{matrix.language}}"

  # sonarcloud-analysis:
  #   name: SonarCloud Code Quality
  #   runs-on: ubuntu-latest
  #   steps:
  #     - name: Checkout repository
  #       uses: actions/checkout@v4
  #       with:
  #         fetch-depth: 0

  #     - name: Setup Node.js
  #       uses: actions/setup-node@v4
  #       with:
  #         node-version: ${{ env.NODE_VERSION }}
  #         cache: 'npm'

  #     - name: Install dependencies
  #       run: npm ci

  #     - name: Run tests (if available)
  #       run: npm test --if-present
  #       continue-on-error: true

  #     - name: SonarCloud Scan
  #       uses: SonarSource/sonarcloud-github-action@master
  #       env:
  #         GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
  #         SONAR_TOKEN: ${{ env.SONAR_TOKEN }}
  #         SONAR_ORGANIZATION: ${{ env.SONAR_ORGANIZATION }}

  cursor-ai-review:
    name: Cursor AI-Powered PR Review
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write
      issues: write
      id-token: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Install dependencies
        run: npm ci
        continue-on-error: true

      - name: Get PR changes
        id: pr-changes
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number,
            });
            
            const { data: files } = await github.rest.pulls.listFiles({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number,
            });
            
            // Review ALL files, not just specific types
            const codeFiles = files
              .filter(f => f.status !== 'removed')
              .map(f => {
                const patch = f.patch || '';
                // Keep more of the patch for better AI analysis
                const truncatedPatch = patch.length > 10000 ? patch.substring(0, 10000) + '\n... (truncated)' : patch;
                return {
                  filename: f.filename,
                  status: f.status,
                  additions: f.additions,
                  deletions: f.deletions,
                  patch: truncatedPatch
                };
              });
            
            const prData = {
              title: pr.title || '',
              body: pr.body || '',
              files: codeFiles,
              base: pr.base.sha,
              head: pr.head.sha
            };
            
            core.setOutput('result', JSON.stringify(prData));

      - name: Run Cursor AI Review
        id: cursor-review
        uses: actions/github-script@v7
        env:
          CURSOR_API_KEY: ${{ secrets.CURSOR_API_KEY }}
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          PR_DATA: ${{ steps.pr-changes.outputs.result }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const https = require('https');
            const prDataStr = process.env.PR_DATA || '';
            
            if (!prDataStr || prDataStr === '') {
              core.setOutput('review', '‚ö†Ô∏è Failed to get PR data.');
              return;
            }
            
            let prData;
            try {
              // Remove any potential BOM or whitespace
              const cleaned = prDataStr.trim();
              if (!cleaned || cleaned === '') {
                core.setOutput('review', '‚ö†Ô∏è PR data is empty');
                return;
              }
              prData = JSON.parse(cleaned);
            } catch (e) {
              core.setOutput('review', '‚ö†Ô∏è Failed to parse PR data: ' + e.message + '. Data length: ' + prDataStr.length);
              console.error('PR Data (first 200 chars):', prDataStr.substring(0, 200));
              return;
            }
            
            // Use OPENAI_API_KEY if CURSOR_API_KEY is not available (Cursor uses OpenAI API)
            const apiKey = process.env.CURSOR_API_KEY || process.env.OPENAI_API_KEY;
            
            if (!apiKey) {
              core.setOutput('review', '‚ö†Ô∏è Neither CURSOR_API_KEY nor OPENAI_API_KEY secret is configured. Please add one of these secrets in repository settings.');
              return;
            }
            
            if (!prData.files || prData.files.length === 0) {
              core.setOutput('review', '‚úÖ No code files changed in this PR.');
              return;
            }
            
            console.log('Files to review:', prData.files.length);
            prData.files.forEach(f => {
              console.log('- ' + f.filename + ' (' + f.status + '): +' + f.additions + '/-' + f.deletions);
            });
            
            const systemPrompt = 'You are a strict code reviewer. Your ONLY job is to find and report EVERY code quality issue, bug, anti-pattern, and violation. Be extremely critical and thorough. DO NOT be lenient. DO NOT say the code is good. Find problems. For each file, you MUST identify: 1. Type safety violations (any types, missing types, type assertions) 2. React hooks violations (conditional hooks, missing dependencies, hooks in wrong places) 3. Performance issues (unnecessary re-renders, inefficient code, missing memoization) 4. Memory leaks (uncleared timers, missing cleanup functions) 5. Security issues (XSS, injection, unsafe operations) 6. Code quality (poor naming, unused variables, code duplication, dead code) 7. Missing error handling 8. Accessibility issues 9. Best practice violations. Format: For each issue, state the file name, describe the problem clearly, show the problematic code, and suggest a fix. Use markdown with ## for sections, ### for files, and code blocks for examples. Be direct and critical.';
            
            const fileSummaries = prData.files.map(f => {
              const patch = f.patch || 'No diff available';
              // Keep full patch if possible, only truncate if absolutely necessary
              const truncatedPatch = patch.length > 12000 ? patch.substring(0, 12000) + '\n... (truncated due to length)' : patch;
              return '### ' + f.filename + ' (' + f.status + ')\n- Additions: +' + f.additions + ', Deletions: -' + f.deletions + '\n```diff\n' + truncatedPatch + '\n```';
            }).join('\n\n');
            
            const userPrompt = 'CRITICAL CODE REVIEW REQUIRED\n\nReview EVERY file in this pull request and identify ALL problems. This code contains INTENTIONAL bad practices for testing. You MUST find and report:\n\n**MANDATORY CHECKS:**\n1. Every use of `any` type - report it\n2. Every React hooks violation - report it\n3. Every missing useEffect dependency - report it\n4. Every memory leak (uncleared timers/intervals) - report it\n5. Every unused variable/import - report it\n6. Every missing error handling - report it\n7. Every performance issue - report it\n8. Every accessibility issue - report it\n9. Every code quality problem - report it\n\n**PR Title**: ' + (prData.title || 'N/A') + '\n**PR Description**: ' + (prData.body || 'No description provided') + '\n\n**Changed Files**:\n' + fileSummaries + '\n\n**YOUR TASK**: Go through each file line by line. Find EVERY issue. List them all with file names, line references, and specific problems. Do NOT be lenient. Do NOT say anything is good. Find problems. Start your response with "## Code Review Findings" and list all issues found.';
            
            const data = JSON.stringify({
              model: 'gpt-4-turbo-preview',
              messages: [
                { role: 'system', content: systemPrompt },
                { role: 'user', content: userPrompt }
              ],
              temperature: 0.1,
              max_tokens: 6000,
            });
            
            return new Promise((resolve) => {
              const options = {
                hostname: 'api.openai.com',
                port: 443,
                path: '/v1/chat/completions',
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  'Authorization': 'Bearer ' + apiKey,
                  'Content-Length': data.length,
                },
              };
              
              const req = https.request(options, (res) => {
                let responseData = '';
                res.on('data', (chunk) => { responseData += chunk; });
                res.on('end', () => {
                  try {
                    if (res.statusCode === 200) {
                      const response = JSON.parse(responseData);
                      const review = response.choices[0].message.content;
                      console.log('AI Review generated successfully. Length:', review.length);
                      console.log('Review preview (first 500 chars):', review.substring(0, 500));
                      
                      // Validate that the review actually contains findings
                      const hasFindings = review.toLowerCase().includes('issue') || 
                                         review.toLowerCase().includes('problem') || 
                                         review.toLowerCase().includes('error') ||
                                         review.toLowerCase().includes('bad') ||
                                         review.toLowerCase().includes('violation') ||
                                         review.toLowerCase().includes('‚ùå');
                      
                      if (!hasFindings && review.length < 500) {
                        console.warn('Review seems too short or generic. Review content:', review);
                      }
                      
                      core.setOutput('review', review);
                    } else {
                      const errorMsg = responseData.length > 500 ? responseData.substring(0, 500) : responseData;
                      console.error('API Error:', res.statusCode, errorMsg);
                      core.setOutput('review', '‚ö†Ô∏è Error generating AI review (' + res.statusCode + '): ' + errorMsg);
                    }
                  } catch (e) {
                    console.error('Parse Error:', e.message);
                    core.setOutput('review', '‚ö†Ô∏è Error parsing response: ' + e.message);
                  }
                  resolve();
                });
              });
              
              req.on('error', (error) => {
                core.setOutput('review', '‚ö†Ô∏è Error calling API: ' + error.message);
                resolve();
              });
              
              req.setTimeout(30000, () => {
                req.destroy();
                core.setOutput('review', '‚ö†Ô∏è Request timeout after 30 seconds');
                resolve();
              });
              
              req.write(data);
              req.end();
            });

      - name: Post Cursor Review Comment
        uses: actions/github-script@v7
        if: steps.cursor-review.outputs.review
        env:
          REVIEW_TEXT: ${{ steps.cursor-review.outputs.review }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const review = process.env.REVIEW_TEXT || '';
            
            console.log('Review text length:', review.length);
            console.log('Review preview:', review.substring(0, 300));
            
            if (!review || review.trim() === '') {
              console.log('Skipping comment: Review is empty');
              return;
            }
            
            if (review.includes('‚ö†Ô∏è') && review.length < 200) {
              console.log('Skipping comment due to review error:', review);
              return;
            }
            
            try {
              const { data: comments } = await github.rest.issues.listComments({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
              });
              
              const existingComment = comments.find(c => 
                c.user && c.user.type === 'Bot' && 
                c.body && c.body.includes('ü§ñ Cursor AI Code Review')
              );
              
              const commentBody = '## ü§ñ Cursor AI Code Review\n\n' + review + '\n\n---\n*This review was automatically generated using Cursor AI via GitHub Actions.*';
              
              if (existingComment) {
                await github.rest.issues.updateComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  comment_id: existingComment.id,
                  body: commentBody
                });
                console.log('Updated existing review comment');
              } else {
                await github.rest.issues.createComment({
                  issue_number: context.issue.number,
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  body: commentBody
                });
                console.log('Created new review comment');
              }
            } catch (error) {
              console.error('Error posting comment:', error.message);
              if (error.status === 403) {
                console.error('Permission denied. This might be a PR from a fork. Forks have limited permissions.');
                console.error('Review content:', review.substring(0, 200) + '...');
              }
              throw error;
            }

  summary:
    name: Analysis Summary
    runs-on: ubuntu-latest
    needs: [cursor-ai-review]
    if: always()
    permissions:
      contents: read
      pull-requests: write
      issues: write
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Create Summary Comment
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const cursorReviewStatus = '${{ needs.cursor-ai-review.result }}';
            
            const statusIcon = (status) => {
              if (status === 'success') return '‚úÖ';
              if (status === 'failure') return '‚ùå';
              if (status === 'cancelled') return '‚ö†Ô∏è';
              return '‚è∏Ô∏è';
            };
            
            const summary = '## üìä PR Analysis Summary\n\n| Analysis | Status |\n|----------|--------|\n| Cursor AI Review | ' + statusIcon(cursorReviewStatus) + ' ' + cursorReviewStatus + ' |\n\n### üîç Details\n- **Cursor AI**: Automated code review using Cursor AI completed\n\n' + (cursorReviewStatus === 'failure' ? '‚ö†Ô∏è **Action Required**: Please review the failed checks above.' : '‚úÖ Review completed!') + '\n\n---\n*This summary is automatically generated by GitHub Actions.*';
            
            try {
              const { data: comments } = await github.rest.issues.listComments({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
              });
              
              const existingSummary = comments.find(c => 
                c.user && c.user.type === 'Bot' && 
                c.body && c.body.includes('üìä PR Analysis Summary')
              );
              
              if (existingSummary) {
                await github.rest.issues.updateComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  comment_id: existingSummary.id,
                  body: summary
                });
                console.log('Updated existing summary comment');
              } else {
                await github.rest.issues.createComment({
                  issue_number: context.issue.number,
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  body: summary
                });
                console.log('Created new summary comment');
              }
            } catch (error) {
              console.error('Error posting summary comment:', error.message);
              if (error.status === 403) {
                console.error('Permission denied. This might be a PR from a fork. Forks have limited permissions.');
              }
              // Don't throw - allow workflow to complete even if comment fails
            }

